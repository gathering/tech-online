<!DOCTYPE html>
<html>
  <head>
    <style>
      * {
        font-family: -apple-system, BlinkMacSystemFont, sans-serif,
          "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
      }

      html,
      body {
        height: 100%;
        width: 100%;
      }

      #kropp {
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 0;
        padding: 0;
      }

      #kropp, #container {
        background-color: red;
      }

      #kropp.success, #kropp.success > #container {
        background-color: green;
      }

      #ja {
        display: none;
      }

      #kropp.success > #container > #ja {
        display: block;
      }

      #kropp.success > #container > #nei {
        display: none;
      }

      #container {
        text-align: center;
        padding: 2em;
      }

      .imageMagic .container, .imageMagic.image {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        overflow: hidden;
        background-size: cover;
        background-position: center;
        opacity: 0;
        z-index: -2;
        transition: opacity 2s ease-in;
      }
      .imageMagic .title {
        position: absolute;
        bottom: 0;
        right: 0;
        background-color: black;
        color: white;
        padding: 1em;
        opacity: 0.8;
      }
      .imageMagic .container, .imageMagic.image.active {
        z-index: -1;
        opacity: 1;
      }
    </style>
  </head>
  <body id="kropp">
    <div id="container">
      <div id="nei">
        <h1>Internett sier: NEI NEI NEI VIL IKKE!</h1>
      </div>
      <div id="ja">
        <h1>MMMMM SWEET INTERNETT!</h1>
      </div>
      <h2 id="dato">DATO</h2>
    </div>
    <script>
      const createImageMagic = ({
        target = '#image-magic-container',
        rotateDelay = 10000,
        loadDelay = 3000,
        loopDelay = 1000,
        // Might be useful if we want to forward information about current image somewhere
        onChanged,
        images = [],
      }) => {
        const elements = {
          container: undefined,
          active: undefined,
          inactive: undefined,
          title: undefined,
        };
        let visible = false;
        let looping = true;
        let timeToChange = false;
        let activeImage = 0;

        function show() {
          elements.container?.classList.add('active');
          visible = true;
        }

        function hide() {
          elements.container?.classList.add('active');
          visible = false;
        }

        function destroy() {
          looping = false;
          hide();
          setTimeout(() => {
            elements.container.remove();
            elements.active.remove();
            elements.inactive.remove();
          }, loopDelay);
        }

        function expireImageIn(ms) {
          setTimeout(() => { timeToChange = true; }, rotateDelay);
        }

        function setRandomActiveImage() {
          activeImage = Math.floor(Math.random() * images.length);
        }

        async function changeImage() {
          return new Promise((resolve, reject) => {
            setRandomActiveImage();
            const image = images[activeImage];
            elements.inactive.style = `background-image: url(${ image.url })`;

            // Wait for image to load. For now we just a assume X time
            // rather than actually detecting if image is loaded.
              setTimeout(() => {
                let inactive = elements.inactive;
                elements.inactive = elements.active;
                elements.active = inactive;

                const inactiveTitle = elements.inactiveTitle;
                elements.inactiveTitle = elements.activeTitle;
                elements.activeTitle = inactiveTitle;

                elements.active.classList.add('active');
                elements.inactive.classList.remove('active');
                elements.activeTitle.innerHTML = `<strong>Bilde</strong>: ${image.title || image.url.split('/').pop()}`

                resolve();

                if (onChanged) {
                  onChanged(image);
                }
              }, loadDelay);
          });
        }

        function getElementWithClass(classname) {
          const elm = document.createElement('div');
          elm.className = `imageMagic ${classname}`;
          return elm;
        }

        async function loop() {
          if (timeToChange) {
            timeToChange = false;

            if (visible) {
              await changeImage();
            }

            expireImageIn(rotateDelay);
          }
          if (looping) {
            setTimeout(() => {
              loop();
            }, loopDelay);
          }
        }

        async function init() {
          elements.container = getElementWithClass('container');
          elements.active = getElementWithClass('image');
          elements.activeTitle = getElementWithClass('title');
          elements.inactive = getElementWithClass('image');
          elements.inactiveTitle = getElementWithClass('title');

          elements.active.appendChild(elements.activeTitle);
          elements.inactive.appendChild(elements.inactiveTitle);
          elements.container.appendChild(elements.active);
          elements.container.appendChild(elements.inactive);
          document.querySelector(target).appendChild(elements.container);

          setRandomActiveImage();
          await changeImage();
          expireImageIn(rotateDelay);

          looping = true;
          loop();
        }

        init();

        return {
          show,
          hide,
          destroy,
          init,
        };
      }
    </script>
    <script>
      const kropp = document.getElementById("kropp");
      const dato = document.getElementById("dato");
      const imageMagic = createImageMagic({
        target: '#kropp',
        // Random dump of 2019 MSPaint urls, are there other cool sources we
        // could pick from. Either manually or dynamically?
        images: [
          { url: 'http://ftp.gathering.org/TG/2019/CreativeCompos/MSPaint/Behind_Enemy_Lines_by_Even_aka_Evendeejay.png' },
          { url: 'http://ftp.gathering.org/TG/2019/CreativeCompos/MSPaint/Bewitched_by_Klara_aka_Klarita.png' },
          { url: 'http://ftp.gathering.org/TG/2019/CreativeCompos/MSPaint/Demonic_Cuteness_by_Maja_aka_Drifandi.png' },
          { url: 'http://ftp.gathering.org/TG/2019/CreativeCompos/MSPaint/Drage_by_Simone_Hoem_aka_TlexSHF.PNG' },
          { url: 'http://ftp.gathering.org/TG/2019/CreativeCompos/MSPaint/Elefanten_by_Mina_aka_Kvaa99.png' },
          { url: 'http://ftp.gathering.org/TG/2019/CreativeCompos/MSPaint/Hva_man_rekker_p%c3%a5_en_time_by_Tonje_aka_tawd92.png' },
          { url: 'http://ftp.gathering.org/TG/2019/CreativeCompos/MSPaint/I_Hate_My_Job_by_Camilla_aka_Mills.png' },
          { url: 'http://ftp.gathering.org/TG/2019/CreativeCompos/MSPaint/Oppgradert_by_Inger_aka_Iserith.png' },
          { url: 'http://ftp.gathering.org/TG/2019/CreativeCompos/MSPaint/Resist_by_Sebastian_Wilhelmsen_aka_Wilhelmsen.png' },
          { url: 'http://ftp.gathering.org/TG/2019/CreativeCompos/MSPaint/Siljeeva_by_Silje_Eva_Kvitle_aka_716c8ded96ae4e63bbf6a8e844.jpg' },
          { url: 'http://ftp.gathering.org/TG/2019/CreativeCompos/MSPaint/Sweet_dreams_by_Amalie_aka_Harley_Quinn.png' },
          { url: 'http://ftp.gathering.org/TG/2019/CreativeCompos/MSPaint/The_Creature_Within_by_Mariel_Simone_aka_MillisRose.png' },
          { url: 'http://ftp.gathering.org/TG/2019/CreativeCompos/MSPaint/Unironic_Dab_by_Erlend_aka_Elvi75.png' },
          { url: 'http://ftp.gathering.org/TG/2019/CreativeCompos/MSPaint/Were_No_Strangers_To_Love_by_Hanna_Nikoline.png' },
          { url: 'http://ftp.gathering.org/TG/2019/CreativeCompos/MSPaint/chita_portrait_by_s%c3%b8lve.png' },
          { url: 'http://ftp.gathering.org/TG/2019/CreativeCompos/MSPaint/the_lynx_and_the_leech_by_adrian_aka_ArtF%c3%a6g.png' },
        ],
      });

      function jadda() {
        kropp.classList.add("success");
        imageMagic.show();
      }
      function neida() {
        kropp.classList.remove("success");
        imageMagic.hide();
      }

      function sjekk() {
        fetch("https://techo.gathering.org/ping", {
          cache: "no-cache",
          mode: "cors",
        })
          .then((response) => {
            if (response.ok) {
              jadda();
            } else {
              neida();
            }
          })
          .catch((err) => {
            neida();
            console.warn(err);
          });
      }

      function setDate() {
        const date = new Date();

        dato.innerText = `${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`;
      }

      sjekk();
      setDate();

      setInterval(sjekk, 1000);
      setInterval(setDate, 970);
    </script>
  </body>
</html>
